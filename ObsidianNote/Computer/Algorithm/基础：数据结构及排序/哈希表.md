# 哈希表核心原理
哈希表是可以通过 `key` 在 $O(1)$ 的时间复杂度内查找到这个 `key` 对应的 `value`。`key` 的类型可以是数字、字符串等多种类型。
哈希表的底层实现就是一个数组（称之为 `table`）。它先把这个 `key` 通过一个哈希函数（称之为 `hash`）转化成数组里面的索引，然后增删查改操作和数组基本相同：
```cpp
// 哈希表伪码逻辑
class MyHashMap {

private:
    vector<void*> table;

public:
    // 增/改，复杂度 O(1)
    void put(auto key, auto value) {
        int index = hash(key);
        table[index] = value;
    }

    // 查，复杂度 O(1)
    auto get(auto key) {
        int index = hash(key);
        return table[index];
    }

    // 删，复杂度 O(1)
    void remove(auto key) {
        int index = hash(key);
        table[index] = nullptr;
    }

private:
    // 哈希函数，把 key 转化成 table 中的合法索引
    // 时间复杂度必须是 O(1)，才能保证上述方法的复杂度都是 O(1)
    int hash(auto key) {
        // ...
    }
};
```

## 关键概念及原理
哈希表中，不可能出现两个相同的 `key`，而 `value` 是可以重复的。
**哈希表中键的遍历顺序是无序的，不能依赖哈希表的遍历顺序来编写程序。**
### 哈希函数
哈希函数的作用是把任意长度的输入（key）转化成固定长度的输出（索引）。
**这个函数还要保证的一点是，输入相同的 `key`，输出也必须要相同，这样才能保证哈希表的正确性**。
### 哈希冲突
如果两个不同的 `key` 通过哈希函数得到了相同的索引，这种情况就叫做「哈希冲突」。

哈希冲突不可能避免，只能在算法层面妥善处理出现哈希冲突的情况。
哈希冲突是一定会出现的，因为这个 `hash` 函数相当于是把一个无穷大的空间映射到了一个有限的索引空间，所以必然会有不同的 `key` 映射到同一个索引上。

对于哈希冲突，两种常见的解决方法，一种是**拉链法**，另一种是**线性探查法**（也被叫做**开放寻址法**）。
- 拉链法相当于是哈希表的底层数组并不直接存储 `value` 类型，而是存储一个链表，当有多个不同的 `key` 映射到了同一个索引上，这些 `key -> value` 对儿就存储在这个链表中，这样就能解决哈希冲突的问题。
- 而线性探查法的思路是，一个 `key` 发现算出来的 `index` 值已经被别的 `key` 占了，那么它就去 `index + 1` 的位置看看，如果还是被占了，就继续往后找，直到找到一个空的位置为止。
### 负载因子
负载因子是一个哈希表装满的程度的度量。一般来说，负载因子越大，说明哈希表里面存储的 `key-value` 对越多，哈希冲突的概率就越大，哈希表的操作性能就越差。

**负载因子的计算公式也很简单，就是 `size / table.length`**。其中 `size` 是哈希表里面的 `key-value` 对的数量，`table.length` 是哈希表底层数组的容量。

用拉链法实现的哈希表，负载因子可以无限大，因为链表可以无限延伸；用线性探查法实现的哈希表，负载因子不会超过 1。

**当哈希表内元素达到负载因子时，哈希表会扩容**。就是把哈希表底层 `table` 数组的容量扩大，把数据搬移到新的大数组中。`size` 不变，`table.length` 增加，负载因子就减小了。


**只有那些不可变类型，才能作为哈希表的 `key`**。所谓不可变类型，就是说这个对象一旦创建，它的值就不能再改变了。

