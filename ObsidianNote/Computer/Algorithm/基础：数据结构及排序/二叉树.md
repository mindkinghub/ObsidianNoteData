# 二叉树基础及常见类型
## 几种常见的二叉树
![[attachments/Pasted image 20251019002429.png]]
上面就是一棵普通的二叉树，几个关键术语：
1. 每个节点下方直接相连的节点称为**子节点**，上方直接相连的节点称为**父节点**。比方说节点 `3` 的父节点是 `1`，左子节点是 `5`，右子节点是 `6`；节点 `5` 的父节点是 `3`，左子节点是 `7`，没有右子节点。
2. 以子节点为根的树称为**子树**。比方说节点 `3` 的左子树是节点 `5` 和 `7` 组成的树，右子树是节点 `6` 和 `8` 组成的树。
3. 最上方那个没有父节点的节点 `1` 为**根节点**，最下层没有子节点的节点 `4`、`7`、`8` 为**叶子节点**。
4. 从根节点到最下方叶子节点经过的节点个数为二叉树的最大深度/高度，上面这棵树的最大深度是 `4`，即从根节点 `1` 到叶子节点 `7` 或 `8` 的路径上的节点个数。

### 满二叉树
满二叉树就是每一层节点都是满的，整棵树像一个正三角形：
![[attachments/Pasted image 20251019002734.png]]
**满二叉树的节点个数好算**。假设深度为 `h`，那么总节点数就是 $2^h - 1$

### 完全二叉树
二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的：
![[attachments/Pasted image 20251019002918.png]]
完全二叉树的特点：由于它的节点紧凑排列，如果从左到右从上到下对它的每个节点编号，那么父子节点的索引存在明显的规律。
**完全二叉树的左右子树中，至少有一棵是满二叉树**。

### 二叉搜索树
二叉搜索树（Binary Search Tree，简称 BST）是一种很常见的二叉树，它的定义是：
- 对于树中的每个节点，其**左子树的每个节点**的值都要小于这个节点的值，**右子树的每个节点**的值都要大于这个节点的值。简单记为「左小右大」。
![[attachments/Pasted image 20251019003317.png]]
### 高度平衡二叉树
高度平衡二叉树（Height-Balanced Binary Tree）是一种特殊的二叉树，**它的「每个节点」的左右子树的高度差不超过 1**。
![[attachments/Pasted image 20251019003523.png]]
假设高度平衡二叉树中共有 N 个节点，那么高度平衡二叉树的高度是 $O(log⁡N)$。

## 二叉树的实现方式
```cpp
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 可以这样构建一棵二叉树：
TreeNode* root = new TreeNode(1);
root->left = new TreeNode(2);
root->right = new TreeNode(3);
root->left->left = new TreeNode(4);
root->right->left = new TreeNode(5);
root->right->right = new TreeNode(6);

// 构建出来的二叉树是这样的：
//     1
//    / \
//   2   3
//  /   / \
// 4   5   6
```

# 二叉树的递归/层次遍历
二叉树只有**递归遍历**和**层序遍历**这两种，再无其他。递归遍历可以衍生出 DFS 算法，层序遍历可以衍生出 BFS 算法。

递归遍历二叉树节点的顺序是固定的，但是有三个关键位置，在不同位置插入代码，会产生不同的效果。
层序遍历二叉树节点的顺序也是固定的，但是有三种不同的写法，对应不同的场景。

## 递归遍历（DFS）
```cpp
// 基本的二叉树节点
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 二叉树的递归遍历框架
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    traverse(root->left);
    traverse(root->right);
}
```

递归遍历节点的顺序（即 `root` 在树上的移动顺序）**仅取决于左右子节点的递归调用顺序，与其他代码无关**。

所谓的前中后序遍历，其实就是在二叉树遍历框架的不同位置写代码：
```cpp
// 二叉树的遍历框架
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```
前序位置的代码会在进入节点时立即执行；中序位置的代码会在左子树遍历完成后，遍历右子树之前执行；后序位置的代码会在左右子树遍历完成后执行

二叉搜索树（BST） 的**中序遍历**结果是**有序的**
## 层次遍历（BFS）
遍历顺序是从最左侧开始，一列一列地走到最右侧。
层序遍历需要借助队列来实现，而且根据不同的需求，可以有三种不同的写法
写法一：
```cpp
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    std::queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* cur = q.front();
        q.pop();
        // 访问 cur 节点
        std::cout << cur->val << std::endl;
        
        // 把 cur 的左右子节点加入队列
        if (cur->left != nullptr) {
            q.push(cur->left);
        }
        if (cur->right != nullptr) {
            q.push(cur->right);
        }
    }
}
```
这种写法最大的优势就是简单。每次把队头元素拿出来，然后把它的左右子节点加入队列。
这种写法的缺点是，无法知道当前节点在第几层。知道节点的层数是个常见的需求

写法二：
```cpp
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            // 访问 cur 节点，同时知道它所在的层数
            cout << "depth = " << depth << ", val = " << cur->val << endl;

            // 把 cur 的左右子节点加入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        depth++;
    }
}
```
队列的长度 `sz` 一定要在循环开始前保存下来
是最常用的层序遍历写法。

写法三：
在写法一的基础上添加一个 `State` 类，让每个节点自己负责维护自己的路径权重和
```cpp
class State {
public:
    TreeNode* node;
    int depth;

    State(TreeNode* node, int depth) : node(node), depth(depth) {}
};

void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<State> q;
    // 根节点的路径权重和是 1
    q.push(State(root, 1));

    while (!q.empty()) {
        State cur = q.front();
        q.pop();
        // 访问 cur 节点，同时知道它的路径权重和
        cout << "depth = " << cur.depth << ", val = " << cur.node->val << endl;

        // 把 cur 的左右子节点加入队列
        if (cur.node->left != nullptr) {
            q.push(State(cur.node->left, cur.depth + 1));
        }
        if (cur.node->right != nullptr) {
            q.push(State(cur.node->right, cur.depth + 1));
        }
    }
}
```
