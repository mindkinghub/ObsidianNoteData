

1. 时空复杂度用 Big O 表示法表示（类似 $O(1)$,$O(n^2)$,$O(logn)$ 等）。**它们都是估计值，不需要精确计算，常数项和低增长项都可以忽略，仅需保留最高增长项**。
	比方说 $O(2n^2+3n+1)$等同于 $O(n^2)$，$O(1000n+1000)$等同于$O(n)$。
2. 我们分析算法复杂度时，分析的是最坏情况的复杂度。
3. 时间复杂度用来衡量一个算法的执行效率，空间复杂度用来衡量算法的内存消耗，它们都是越小越好。
	比方说时间复杂度 $O(n)$ 的算法比 $O(n^2)$ 的算法执行效率高，空间复杂度$O(1)$ 的算法比 $O(n)$的算法内存消耗小。当然，一般我们要说明这个 n 代表什么，比如 n 代表输入的数组的长度。
4. 如何估算？**现在你可以简单理解：时间复杂度大部分情况下就是看 for 循环的最大嵌套层数；空间复杂度就看算法申请了多少空间来存储数据**。
>[!note]
>以上的分析方法中，有些细节并不严谨：
>1. 按照 for 循环的嵌套层数来估算时间复杂度是简化的方法，其实不完全准确。
>2. 大部分时候我们是分析最坏情况下的复杂度，但是对于数据结构 API 的复杂度衡量，我们会分析平均复杂度。

## 时间/空间复杂度案例分析
**示例一，时间复杂度 $O(n)$，空间复杂度 $O(1)$**：
```cpp
// 输入一个整数数组，返回所有元素的和
int getSum(vector<int>& nums) {
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
    }
    return sum;
}
```
算法包含一个 for 循环遍历 `nums` 数组，所以时间复杂度是 $O(n)$，其中 `n` 代表 `nums` 数组的长度。
我们的算法只使用了一个 `sum` 变量，这个 `nums` 是题目给的输入，不算在我们算法的空间复杂度里面，所以空间复杂度是 $O(1)$。
**示例二，时间复杂度 $O(n)$，空间复杂度 $O(1)$**：
```cpp
// 当 n 是 10 的倍数时，计算累加和，否则返回 -1
int sum(int n) {
    if (n % 10 != 0) {
        return -1;
    }
    int sum = 0;
    for (int i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```
其实只有当 `n` 是 10 的倍数时，算法才会执行 for 循环，时间复杂度是 $O(n)$。其他情况下算法会直接返回，时间复杂度是 $O(1)$。
但是算法复杂度只考察最坏情况，所以这个算法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。
**示例三，时间复杂度 $O(n^2)$，空间复杂度 $O(1)$**：
```cpp
// 数组是否存在两个数，它们的和为 target？
bool hasTargetSum(vector<int>& nums, int target) {
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}
```
算法嵌套了两层 for 循环，所以时间复杂度是 $O(n^2)$，其中 n 代表 `nums` 数组的长度。
我们的算法只使用了 `i, j` 两个变量，这是常数级别的空间消耗，所以空间复杂度是 $O(1)$。
每层 for 循环在最坏情况下都是$O(n)$的时间复杂度，套在一起，总的时间复杂度是$O(n^2)$。
**示例四，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：
```cpp
void exampleFn(int n) {
    vector<int> nums(n);
}
```
这个函数中创建了一个大小为 `n` 的数组，所以空间复杂度是 $O(n)$。
内存申请操作的时间复杂度可以认为是 $O(1)$，但初始化所有元素的操作相当于一个隐藏的 for 循环，时间复杂度是 $O(n)$。所以总的时间复杂度是 $O(n)$。
时间复杂度并不仅仅体现在你看得到的 for 循环，每一行代码都可能有隐藏的时间复杂度。所以说要了解编程语言提供的常用数据结构实现原理，这是准确分析时间复杂度的基础。
**示例五，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：
```cpp
// 输入一个整数数组，返回一个新的数组，新数组的每个元素是原数组对应元素的平方
vector<int> squareArray(vector<int>& nums) {
    vector<int> res(nums.size());
    for (int i = 0; i < nums.size(); i++) {
        res[i] = nums[i] * nums[i];
    }
    return res;
}
```
算法初始化 `res` 数组需要 $O(n)$的时间复杂度，包含一个 for 循环，时间复杂度也是$O(n)$，总的时间复杂度是还是 $O(n)$ 其中 `n` 代表 `nums` 数组的长度。
我们声明了一个新的数组 `res`，这个数组的长度和 `nums` 数组一样，所以空间复杂度是 $O(n)$。
